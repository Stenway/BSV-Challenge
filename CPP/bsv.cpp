/* (C) Stefan John / Stenway / Stenway.com / 2023 */

#include <iostream>
#include <vector>
#include <string>
#include <optional>
#include <sstream>
#include <fstream>
using namespace std;
using namespace std::string_literals;

// ----------------------------------------------------------------------

static const uint8_t utf8ByteClassLookup[256] = {
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
	0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
	0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
	0x0, 0x0, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
	0x6, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x8, 0x7, 0x7,
	0x9, 0xA, 0xA, 0xA, 0xB, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

static const uint8_t utf8StateTransitionLookup[108] = {
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x3, 0x5, 0x4, 0x6, 0x7, 0x8,
	0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x0, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x5, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

bool isValidUtf8(string& str) {
	uint8_t lastState = 1;
	for (char c : str) {
		uint8_t currentByte = (uint8_t)c;
		uint8_t currentByteClass = utf8ByteClassLookup[currentByte];
		uint8_t newStateLookupIndex = lastState*12+currentByteClass;
		lastState = utf8StateTransitionLookup[newStateLookupIndex];
		if (lastState == 0) { return false; }
	}
	return (lastState == 1);
}

// ----------------------------------------------------------------------

vector<uint8_t> encodeBsv(vector<vector<optional<string>>>& jaggedArray) {
	vector<uint8_t> result;
	bool isFirstLine = true;
	for (auto line : jaggedArray) {
		if (!isFirstLine) { result.push_back(0xFF); }
		isFirstLine = false;
		bool isFirstValue = true;
		for (auto value : line) {
			if (!isFirstValue) { result.push_back(0xFE); }
			isFirstValue = false;
			if (!value.has_value()) { result.push_back(0xFD); }
			else {
				auto strValue = value.value();
				if (strValue.length() == 0) { result.push_back(0xFC); }
				else {
					if (!isValidUtf8(strValue)) { throw runtime_error("Invalid string value"); }
					result.insert(result.end(), strValue.begin(), strValue.end());
				}
			}
		}
	}
	return result;
}

vector<vector<optional<string>>> decodeBsv(vector<uint8_t>& bytes) {
	vector<vector<optional<string>>> result{};
	vector<optional<string>> currentLine{};
	long currentIndex = -1;
	for (;;) {
		long lastIndex = currentIndex;
		long valueBytesLength;
		for (;;) {
			currentIndex++;
			if (currentIndex >= bytes.size()) {
				currentIndex = -1;
				valueBytesLength = bytes.size()-lastIndex-1;
				break;
			}
			if (bytes[currentIndex] >= 0xFE) {
				valueBytesLength = currentIndex-lastIndex-1;
				break;
			}
		}
		if (valueBytesLength == 1 && bytes[lastIndex+1] == 0xFD) { currentLine.push_back({}); }
		else if (valueBytesLength == 1 && bytes[lastIndex+1] == 0xFC) { currentLine.push_back(""); }
		else if (valueBytesLength >= 1) {
			string strValue(bytes.begin()+lastIndex+1, bytes.begin()+lastIndex+1+valueBytesLength);
			if (!isValidUtf8(strValue)) { throw runtime_error("Invalid string value"); }
			currentLine.push_back(strValue);
		} else if ((((currentIndex >= 0 && bytes[currentIndex] == 0xFF) || (currentIndex < 0)) && ((lastIndex < 0) || (lastIndex >= 0 && bytes[lastIndex] == 0xFF))) == false) { throw runtime_error("Invalid BSV value byte sequence"); }
		if (currentIndex < 0) { break; }
		else if (currentIndex >= 0 && bytes[currentIndex] == 0xFF) {
			result.push_back(currentLine);
			currentLine = {};
		}
	}
	result.push_back(currentLine);
	return result;
}

// ----------------------------------------------------------------------

vector<uint8_t> loadFile(string filePath) {
	ifstream file(filePath, ios_base::binary);
	if (!file) { throw runtime_error("Could not open file"); }
	
	file.seekg(0, std::ios_base::end);
	auto size = file.tellg();
	file.seekg(0, std::ios_base::beg);
	if (size < 0) { throw runtime_error("Could not determine file size"); }
	
	vector<uint8_t> bytes(size);
	file.read((char*)bytes.data(), size);
	if (file.gcount() != size) { throw runtime_error("Not all bytes read"); }
	return bytes;
}

void saveFile(vector<uint8_t>& bytes, string filePath) {
	ofstream file(filePath, ios_base::binary);
	file.write((char*)bytes.data(), bytes.size());
	if (!file.good()) { throw runtime_error("Writing all bytes failed"); }
}

// ----------------------------------------------------------------------

void saveBsv(vector<vector<optional<string>>>& jaggedArray, string filePath) {
	auto bytes = encodeBsv(jaggedArray);
	saveFile(bytes, filePath);
}

vector<vector<optional<string>>> loadBsv(string filePath) {
	auto bytes = loadFile(filePath);
	return decodeBsv(bytes);
}

// ----------------------------------------------------------------------

string jaggedArrayToString(vector<vector<optional<string>>>& jaggedArray) {
	stringstream result;
	result << "[";
	for (auto line : jaggedArray) {
		result << "\n  [";
		bool isFirst = true;
		for (auto value : line) {
			if (!isFirst) { result << ", "; }
			isFirst = false;
			if (!value.has_value()) { result << "null"; }
			else {
				result << "\"";
				result << value.value();
				result << "\"";
			}
		}
		result << "]";
	}
	result << "\n]";
	return result.str();
}

// ----------------------------------------------------------------------

int main() {
	vector<vector<optional<string>>> jaggedArray{
		{"Hello", "🌎", {}, ""},
		{"A\0B\nC"s, "Test 𝄞"}
	};
	cout << jaggedArrayToString(jaggedArray) << endl;
	
	auto bytes = encodeBsv(jaggedArray);
	auto decodedJaggedArray = decodeBsv(bytes);
	cout << jaggedArrayToString(decodedJaggedArray) << endl;
	
	saveBsv(jaggedArray, "Test.bsv");
	
	auto loadedJaggedArray = loadBsv("Test.bsv");
	cout << jaggedArrayToString(loadedJaggedArray) << endl;
	
	saveBsv(loadedJaggedArray, "TestResaved.bsv");

	return 0;
}