import std/options

const utf8ByteClassLookup: array[256, byte] = [
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
    0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
    0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
    0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
    0x0, 0x0, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
    0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
    0x6, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x8, 0x7, 0x7,
    0x9, 0xA, 0xA, 0xA, 0xB, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
]

const utf8StateTransitionLookup: array[108, byte] = [
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x3, 0x5, 0x4, 0x6, 0x7, 0x8,
    0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x5, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
]

proc isValidUtf8(str: string): bool =
    var lastState: byte = 1;
    for c in str:
        var currentByteClass = utf8ByteClassLookup[c.byte]
        var newStateLookupIndex = lastState*12+currentByteClass
        lastState = utf8StateTransitionLookup[newStateLookupIndex]
        if lastState == 0: return false
    return (lastState == 1)

# ----------------------------------------------------------------------

proc encodeBsv(jaggedArray: seq[seq[Option[string]]]): string =
    result = ""
    var isFirstLine = true
    for line in jaggedArray:
        if isFirstLine == false: result.add("\xFF")
        isFirstLine = false
        var isFirstValue = true
        for value in line:
            if isFirstValue == false: result.add("\xFE")
            isFirstValue = false
            if value.issome == false: result.add("\xFD")
            else:
                var strValue = value.get
                if strValue.len == 0: result.add("\xFC")
                else:
                    if isValidUtf8(strValue) == false: raise newException(ValueError, "Invalid string value")
                    result.add(strValue)
    return result

proc decodeBsv(bytes: string): seq[seq[Option[string]]] =
    result = @[]
    var currentLine: seq[Option[string]] = @[]
    var currentIndex = -1
    while true:
        var lastIndex = currentIndex
        while true:
            currentIndex += 1
            if currentIndex >= bytes.len:
                currentIndex = -1
                break
            if bytes[currentIndex].byte >= 0xFE: break
        var valueBytes = bytes[(lastIndex+1)..(if currentIndex < 0: bytes.len else: currentIndex)-1]
        if valueBytes.len == 1 and valueBytes[0].byte == 0xFD: currentLine.add(none(string))
        elif valueBytes.len == 1 and valueBytes[0].byte == 0xFC: currentLine.add(some(""))
        elif valueBytes.len >= 1:
            if isValidUtf8(valueBytes) == false: raise newException(ValueError, "Invalid string value")
            currentLine.add(some(valueBytes))
        if currentIndex < 0: break
        elif currentIndex >= 0 and bytes[currentIndex].byte == 0xFF:
            result.add(currentLine)
            currentLine = @[]
    result.add(currentLine)
    return result

# ----------------------------------------------------------------------

proc saveBsv(jaggedArray: seq[seq[Option[string]]], filePath: string) =
    writeFile(filePath, encodeBsv(jaggedArray))

proc loadBsv(filePath: string): seq[seq[Option[string]]] =
    return decodeBsv(readFile(filePath))

# ----------------------------------------------------------------------

var jaggedArray: seq[seq[Option[string]]] = @[
    @[some("Hello"), some("🌎"), none(string), some("")],
    @[some("A\0B\nC"), some("Test 𝄞")]
]
echo jaggedArray

var bytes = encodeBsv(jaggedArray)
var decodedJaggedArray = decodeBsv(bytes)
echo decodedJaggedArray

saveBsv(jaggedArray, "Test.bsv")
var loadedJaggedArray = loadBsv("Test.bsv")
echo loadedJaggedArray

saveBsv(loadedJaggedArray, "TestResaved.bsv")