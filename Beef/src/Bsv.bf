/* (C) Stefan John / Stenway / Stenway.com / 2023 */

using System;
using System.Collections;
using System.IO;
using System.Text;

namespace Bsv
{
	class Utf8Validator {
		uint8[256] utf8ByteClassLookup = .(
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
			0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
			0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
			0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
			0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
			0x0, 0x0, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
			0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
			0x6, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x8, 0x7, 0x7,
			0x9, 0xA, 0xA, 0xA, 0xB, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
		);

		uint8[108] utf8StateTransitionLookup = .(
			0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x1, 0x0, 0x0, 0x0, 0x2, 0x3, 0x5, 0x4, 0x6, 0x7, 0x8,
			0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x0, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x5, 0x5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
			0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
		);

		public bool IsValidUtf8(System.Span<uint8> str) {
			uint8 lastState = 1;
			for (let currentByte in str) {
				uint8 currentByteClass = utf8ByteClassLookup[currentByte];
				uint8 newStateLookupIndex = lastState*12+currentByteClass;
				lastState = utf8StateTransitionLookup[newStateLookupIndex];
				if (lastState == 0) { return false; }
			}
			return (lastState == 1);
		}
	}

    class Program
    {
		static Result<List<uint8>> EncodeBsv(List<List<String>> jaggedArray) {
			var result = new List<uint8>();
			var validator = new Utf8Validator();
			defer delete validator;
			var isFirstLine = true;
			for (let line in jaggedArray) {
				if (!isFirstLine) { result.Add(0xFF); }
				isFirstLine = false;
				var isFirstValue = true;
				for (let value in line) {
					if (!isFirstValue) { result.Add(0xFE); }
					isFirstValue = false;
					if (value == null) { result.Add(0xFD); }
					else if (value.Length == 0) { result.Add(0xFC); }
					else {
						var bytes = new uint8[value.Length];
						defer delete bytes;
						Internal.MemCpy(bytes.Ptr, value.Ptr, value.Length);
						if (!validator.IsValidUtf8(bytes)) { return .Err; }
						result.AddRange(bytes);
					}
				}
			}
			return .Ok(result);
		}

		static Result<List<List<String>>> DecodeBsv(List<uint8> bytes) {
			var result = new List<List<String>>();
			var currentLine = new List<String>();
			var currentIndex = -1;
			var validator = new Utf8Validator();
			defer delete validator;
			for (;;) {
				var lastIndex = currentIndex;
				var valueBytesLength = 0;
				for (;;) {
					currentIndex++;
					if (currentIndex >= bytes.Count) {
						currentIndex = -1;
						valueBytesLength = bytes.Count-lastIndex-1;
						break;
					}
					if (bytes[currentIndex] >= 0xFE) {
						valueBytesLength = currentIndex-lastIndex-1;
						break;
					}
				}
				if (valueBytesLength == 1 && bytes[lastIndex+1] == 0xFD) { currentLine.Add(null); }
				else if (valueBytesLength == 1 && bytes[lastIndex+1] == 0xFC) { currentLine.Add(""); }
				else if (valueBytesLength >= 1) {
					var valueBytes = bytes.GetRange(lastIndex+1, valueBytesLength);
					if (!validator.IsValidUtf8(valueBytes)) { return .Err; }
					var strValue = new String((char8*)valueBytes.Ptr, valueBytes.Length);
					Internal.MemCpy(strValue.Ptr, valueBytes.Ptr, valueBytes.Length);
					currentLine.Add(strValue);
				} else if ((((currentIndex >= 0 && bytes[currentIndex] == 0xFF) || (currentIndex < 0)) && ((lastIndex < 0) || (lastIndex >= 0 && bytes[lastIndex] == 0xFF))) == false) { return .Err; }
				if (currentIndex < 0) { break; }
				else if (currentIndex >= 0 && bytes[currentIndex] == 0xFF) {
					result.Add(currentLine);
					currentLine = new List<String>();
				}
			}
			result.Add(currentLine);
			return .Ok(result);
		}

		// ----------------------------------------------------------------------

		static Result<void> SaveBsv(List<List<String>> jaggedArray, String filePath) {
			switch (EncodeBsv(jaggedArray)) {
			case .Ok(let bytes): {
				defer delete bytes;
				File.WriteAll(filePath, bytes);
			}
			case .Err: return .Err;
			}
			return .Ok;
		}

		static Result<List<List<String>>> LoadBsv(String filePath) {
			var bytes = new List<uint8>();
			defer delete bytes;
			File.ReadAll(filePath, bytes);
			return DecodeBsv(bytes);
		}

		// ----------------------------------------------------------------------

		static String JaggedArrayToString(List<List<String>> jaggedArray) {
			var result = new String("[");
			for (let line in jaggedArray) {
				result.Append("\n  [");
				bool isFirst = true;
				for (let value in line) {
					if (!isFirst) { result.Append(", "); }
					isFirst = false;
					if (value == null) { result.Append("null"); }
					else {
						var escaped = scope String();
						value.Escape(escaped);
						result.AppendF("\"{}\"", escaped);
					}
				}
				result.Append("]");
			}
			result.Append("\n]");
			return result;
		}

		static void PrintJaggedArray(List<List<String>> jaggedArray) {
			var str = JaggedArrayToString(jaggedArray);
			Console.WriteLine(str);
			delete str;
		}

		static void DeleteJaggedArray(List<List<String>> jaggedArray) {
			for (let line in jaggedArray) {
				for (let value in line) {
					if (value != null && !value.HasExternalPtr) delete value;
				}
				delete line;
			}
			delete jaggedArray;
		}

		// ----------------------------------------------------------------------

        static void Main()
        {
			var jaggedArray = new List<List<String>>();
			defer DeleteJaggedArray(jaggedArray);
			var line1 = new List<String>(String[] ("Hello", "üåé", null, ""));
			jaggedArray.Add(line1);
			var line2 = new List<String>(String[] ("A\0B\nC", "Test ùÑû"));
			jaggedArray.Add(line2);

			PrintJaggedArray(jaggedArray);

			SaveBsv(jaggedArray, "Test.bsv");

			if (LoadBsv("Test.bsv") case .Ok(let loadedJaggedArray)) {
				defer DeleteJaggedArray(loadedJaggedArray);
				PrintJaggedArray(loadedJaggedArray);

				SaveBsv(loadedJaggedArray, "TestResaved.bsv");
			}
			
        }
    }
}